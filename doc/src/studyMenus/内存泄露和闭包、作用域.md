# 内存泄露和闭包

## 什么是内存泄漏

内存泄漏（Memory Leak）是指程序在申请内存后，无法释放已申请的内存空间，导致系统内存的浪费，最终可能导致系统性能下降甚至崩溃。

在JavaScript中，内存泄漏主要发生在以下几种情况：

1. **意外的全局变量**：未声明的变量会自动成为全局变量，占用内存直到页面关闭
2. **被遗忘的定时器或回调函数**：未清除的`setInterval`或`setTimeout`
3. **闭包引起的内存泄漏**：闭包中引用的外部变量无法被垃圾回收
4. **DOM引用**：保存了DOM元素的引用，但元素已从DOM树中移除
5. **控制台日志**：大量使用`console.log`输出大对象

## 如何检测内存泄漏

1. **Chrome开发者工具**：
   - Performance面板：记录内存使用情况
   - Memory面板：堆快照分析
   - Task Manager：查看页面内存使用

2. **内存使用模式**：
   - 如果内存使用呈锯齿状（上升然后下降），通常是正常的
   - 如果内存使用持续上升，可能存在内存泄漏

## 闭包

闭包（Closure）是指有权访问另一个函数作用域中变量的函数。简单来说，闭包就是一个函数能够记住并访问它的词法作用域，即使当这个函数在其词法作用域之外执行时。

### 闭包的特点

1. **函数嵌套**：闭包涉及函数嵌套
2. **作用域链**：内部函数可以访问外部函数的变量
3. **延长变量生命周期**：外部函数执行完毕后，其变量仍然存在

### 闭包示例
```js
// 闭包示例
function createCounter() {
  let count = 0; // 私有变量
  
  return {
    increment: function() {
      count++;
      return count;
    },
    decrement: function() {
      count--;
      return count;
    },
    getCount: function() {
      return count;
    }
  };
}

// 使用闭包
const counter = createCounter();
console.log(counter.getCount()); // 输出: 0
console.log(counter.increment()); // 输出: 1
console.log(counter.increment()); // 输出: 2
console.log(counter.decrement()); // 输出: 1
```

## 作用域

作用域（Scope）是指程序中定义变量的区域，它决定了变量的可访问性（可见性）。JavaScript中主要有以下几种作用域：

1. **全局作用域（Global Scope）**：
   - 在代码中任何地方都能访问到的变量，拥有全局作用域
   - 未使用var、let或const声明的变量自动成为全局变量

2. **函数作用域（Function Scope）**：
   - 在函数内部声明的变量，只能在函数内部访问
   - 使用var关键字声明的变量具有函数作用域

3. **块级作用域（Block Scope）**：
   - ES6引入的概念，使用let和const声明的变量具有块级作用域
   - 块级作用域由{}包裹

4. **词法作用域（Lexical Scope）**：
   - 也称为静态作用域，变量的作用域在定义时就确定了
   - 闭包正是基于词法作用域工作的


